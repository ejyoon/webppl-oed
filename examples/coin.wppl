var coinWeights = [0.01, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 0.99];

// assumes a.length == b.length
var arraysEqual = function(as,bs) {
    return all(idF, map2(function(a, b) { return a === b }, as, bs))
}

// TODO: return generative model rather than distribution?
// (then can specify inference for each model in argument to EIG)
var biasCoin = function(sequence) {
  Enumerate(function(){
      var p = uniformDraw(coinWeights);
      var sampled = repeat(sequence.length, function() { flip(p) })
      condition(arraysEqual(sampled, sequence))
      return flip(p)
  })
}

var markovCoin = function(sequence) {
    Enumerate(function(){
        var transitionProb = uniformDraw(coinWeights);
        var generateSequence = function(n, flipsSoFar) {
            if (flipsSoFar.length == n) {
                return flipsSoFar;
            } else {
                var lastFlip = last(flipsSoFar);
                return generateSequence(n,
                                        append(flipsSoFar,
                                               flip(transitionProb) ? !lastFlip : lastFlip))
            }
        }

        var firstCoin = flip();
        var sampled = generateSequence(sequence.length, [firstCoin]);
        condition(arraysEqual(sampled, sequence));

        return flip(transitionProb) ? !last(sampled) : last(sampled);
    })
}

// get expected information gain
// this function signature is kind of ugly but webppl can't handle a distribution on functions
// EIG({mSample: function() { uniformDraw([biasCoin, markovCoin]) },
//      xSample: function() { repeat(4, flip) },
//      ySample: function() { flip() }}
//    )

// get actual information gain
// AIG(function() { uniformDraw([biasCoin, markovCoin] )},
//     [true,true,false,true],
//     repeat(10, function() { true }))

var fairCoinN = function(args) {
    var sequence = args.sequence, N = args.N;
    //Enumerate(function(){
        return repeat(N, flip)
    //})
}


var markovSingle = cache(function(sequence) {
    Enumerate(function() {
        var transitionProb = uniformDraw(coinWeights);

        var generateSequence = function(n, flipsSoFar) {
            if (flipsSoFar.length == n) {
                return flipsSoFar;
            } else {
                var lastFlip = last(flipsSoFar);
                return generateSequence(n,
                                        append(flipsSoFar,
                                               flip(transitionProb) ? !lastFlip : lastFlip))
            }
        }
        var firstCoin = flip();
        var sampled = generateSequence(sequence.length, [firstCoin]);
        condition(arraysEqual(sampled, sequence));
        return flip( transitionProb ) ? !last(sampled) : last(sampled);
    })
});

// DECIDE: x includes experiment setting AND measurement properties?
// type is x -> y -> logp
var markovGroup = function(sequence, ys) {
    var yDist = markovSingle(sequence);
    return sum(pam(ys, function(y) { score(yDist, y) }))
}

var biasSingle = cache(function(sequence) {
    Enumerate(function() {
        var p = uniformDraw(coinWeights);
        var sampled = repeat(sequence.length, function() { flip(p) })
        condition(arraysEqual(sampled, sequence))
        return flip(p);
    })
});

var biasGroup = function(sequence, ys) {
    var yDist = biasSingle(sequence);
    return sum(pam(ys, function(y) { score(yDist, y) }))
}

// biasCoinN({sequence: [true,true,true,true], N: 1},
//           [false])


// TODO: add convenience method for converting a model of a single subject response to
// multiple subject responses

util.seedRNG(1)

var N = 20;
var dist = EIG({
    mSample: function() { uniformDraw([markovGroup, biasGroup]) },
    xSample: function() { repeat(4, flip) },
    ySample: function() { repeat(N, flip) },
    infer: {
        Y: function(g) { MH(g, 4000) }
    }
});

dist

// markovSingle([true,true,true,true])



// markovGroup([true,true,true,true],
//             [true,true]
//            )
