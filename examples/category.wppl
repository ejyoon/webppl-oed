var ms78 = {
  as: [
    [1, 1, 1, 0],
    [1, 0, 1, 0],
    [1, 0, 1, 1],
    [1, 1, 0, 1],
    [0, 1, 1, 1]],
  bs: [
    [1, 1, 0, 0],
    [0, 1, 1, 0],
    [0, 0, 0, 1],
    [0, 0, 0, 0]
  ]
};

var log = function(x) {
  return Math.log(x)
}

var exp = function(x) {
  return Math.exp(x)
}

var arrayEq = function(x,y,_i) {
  var nx = x.length;
  var ny = y.length;
  if (nx !== ny) {
    return false
  }

  var loop = function(i) {
    if (i > nx) {
      return true
    } else {
      return x[i] !== y[i] ? false : loop(i+1)
    }
  };

  return loop(0)
}

var independentCue = function(as, bs, alpha, bias, weights) {
  var recall = append(as,bs);

  // returns true if x is in the training set, false if not
  var isRecall = function(x) {
    return filter(function(y) { return arrayEq(x,y) },
                  recall).length > 0;
  }

  Enumerate(function() {
    var object = repeat(4, function() { return flip() ? 1 : 0});

    // a function of dimension index
    var dimensionalEvidenceForA = function(i) {
      var matchingObjects = filter(function(x) { return x[i] == object[i] },
                                   recall);
      var n = matchingObjects.length;
      var nA = filter(function(x) { return as.indexOf(x) > -1 },
                      matchingObjects).length;
      var nB = n - nA;
      return weights[i] * (nA - nB)/n;
    }

    // factor: log-probability that object is an A
    // prob is 1 / (1 + exp(-alpha * sum_j[w_j * I_j]))
    // log prob is -log(1 + exp(-alpha * sum_j[w_j * I_j]))

    var totalEvidence = sum(map(dimensionalEvidenceForA,[0,1,2,3])) + (isRecall(object) ? bias : 0);

    // todo: bias
    var prob = 1 / (1 + exp(-alpha * totalEvidence));

    factor(log(prob));

    return [object, prob];
  })
}

var exemplar = function(as, bs, weights) {
  Enumerate(function() {
    var object = repeat(4, function() { return flip() ? 1 : 0});

    var similarity = function(x,y) {
      var dimMatches = map2(function(xi,yi) {
        return xi == yi
      },x,y);
      var probs = map2(function(b,p) {
        return b ? 1 : p
      },dimMatches, weights);
      return product(probs);
    };


    // sum of similarities to a
    var ssa = sum(map(function(a) { return similarity(object, a) },
                      as));

    // sum of similarities to b
    var ssb = sum(map(function(b) { return similarity(object, b) },
                      bs));

    var prob = ssa / (ssa + ssb);

    return {object: object, prob: prob};

  })


}

// independentCue(ms78.as,
//                ms78.bs,
//                2.7,
//                1,
//                [1.1,2.2,3.3,4.4])


var post = exemplar(ms78.as,
         ms78.bs,
         [0.14,0.16,0.18,0.14]
                   );

var states = post.support();
var probs = map(function(state) { return state.prob}, states)

console.log(probs.sort().join('\n'))
